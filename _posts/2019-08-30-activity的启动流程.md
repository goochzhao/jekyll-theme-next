



## activity的启动流程

- activity--startActivity方法入口

- 调用重载方法

  ```java
   @Override
      public void startActivity(Intent intent, @Nullable Bundle options) {
          if (options != null) {
              startActivityForResult(intent, -1, options);
          } else {
              // Note we want to go through this call for compatibility with
              // applications that may have overridden the method.
              startActivityForResult(intent, -1);
          }
      }
  ```

- startActivityForResult

  ```java
  public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
          @Nullable Bundle options) {
      if (mParent == null) {
          options = transferSpringboardActivityOptions(options);
          Instrumentation.ActivityResult ar =
              mInstrumentation.execStartActivity(
                  this, mMainThread.getApplicationThread(), mToken, this,
                  intent, requestCode, options);
          if (ar != null) {
              mMainThread.sendActivityResult(
                  mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                  ar.getResultData());
          }
          if (requestCode >= 0) {
              // If this start is requesting a result, we can avoid making
              // the activity visible until the result is received.  Setting
              // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
              // activity hidden during this time, to avoid flickering.
              // This can only be done when a result is requested because
              // that guarantees we will get information back when the
              // activity is finished, no matter what happens to it.
              mStartedActivity = true;
          }

          cancelInputsAndStartExitTransition(options);
          // TODO Consider clearing/flushing other event sources and events for child windows.
      } else {
          if (options != null) {
              mParent.startActivityFromChild(this, intent, requestCode, options);
          } else {
              // Note we want to go through this method for compatibility with
              // existing applications that may have overridden it.
              mParent.startActivityFromChild(this, intent, requestCode);
          }
      }
  }
  ```

- Instrumentation

  ```java
  //如果mParent==null,则会调用instrumentation中的execStartActivity方法
  mInstrumentation.execStartActivity(
      this, mMainThread.getApplicationThread(), mToken, this,
      intent, requestCode, options);
          
  ```

```java
public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, Activity target,
        Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;
  ...省略代码
    try {
     ...
        int result = ActivityManager.getService()
            .startActivity(whoThread, who.getBasePackageName(), intent,
                    intent.resolveTypeIfNeeded(who.getContentResolver()),
                    token, target != null ? target.mEmbeddedID : null,
                    requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
//从方法调用看出是通过ActivityManager.getService()
```

- ActivityManager

  ```java
  public static IActivityManager getService() {
      return IActivityManagerSingleton.get();
  }

  private static final Singleton<IActivityManager> IActivityManagerSingleton =
          new Singleton<IActivityManager>() {
              @Override
              protected IActivityManager create() {
                  final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                  final IActivityManager am = IActivityManager.Stub.asInterface(b);
                  return am;
              }
          };
  //通过使用AIDL的方式进行IPC行为，通过ActivityManagerService调用startActivity方法
  ```

- ActivityManagerService

  ```java
  @Override
  public final int startActivity(IApplicationThread caller, String callingPackage,
          Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
          int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
      return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
              resultWho, requestCode, startFlags, profilerInfo, bOptions,
              UserHandle.getCallingUserId());
  }
  //...经过一系列的startActivityAsUser方法重载调用
  public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
              Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
              int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,
              boolean validateIncomingUser) {
       //...
          // TODO: Switch to user app stacks here.
      //通过获取ActivityStarter对象，调用execute()方法
          return mActivityStartController.obtainStarter(intent, "startActivityAsUser")
                  .setCaller(caller)
                  .setCallingPackage(callingPackage)
                  .setResolvedType(resolvedType)
                  .setResultTo(resultTo)
                  .setResultWho(resultWho)
                  .setRequestCode(requestCode)
                  .setStartFlags(startFlags)
                  .setProfilerInfo(profilerInfo)
                  .setActivityOptions(bOptions)
                  .setMayWait(userId)
                  .execute();

      }

  ```

- ActivityStarter

  ```java
  //执行ActivityStarter中的execute()方法
  int execute() {
          try {
              // TODO(b/64750076): Look into passing request directly to these methods to allow
              // for transactional diffs and preprocessing.
              if (mRequest.mayWait) {
                  return startActivityMayWait(...省略);
              } else {
                  return startActivity(...省略);
              }
          } finally {
              onExecutionComplete();
          }
      }
  //...省略
  private int startActivityMayWait(...省略){
     ...
         int res = startActivity(...省略)
      ...
  }
  //一系列重载startActivity
   private int startActivity(..省略) {
          int result = START_CANCELED;
          try {
              mService.mWindowManager.deferSurfaceLayout();
              result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,
                      startFlags, doResume, options, inTask, outActivity);
          } finally {
              // If we are not able to proceed, disassociate the activity from the task. Leaving an
              // activity in an incomplete state can lead to issues, such as performing operations
              // without a window container.
              final ActivityStack stack = mStartActivity.getStack();
              if (!ActivityManager.isStartResultSuccessful(result) && stack != null) {
                  stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,
                          null /* intentResultData */, "startActivity", true /* oomAdj */);
              }
              mService.mWindowManager.continueSurfaceLayout();
          }

          postStartActivityProcessing(r, result, mTargetStack);

          return result;
      }
  //startActivityUnchecked方法
  private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
          IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
          int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {
      ...
      if (mDoResume) {
          ...
          if (!mTargetStack.isFocusable()
              ...
          } else {
              mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                      mOptions);
          }
      } else {
         ...
      }
      ...
      return START_SUCCESS;
  }
   //调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。
    boolean resumeFocusedStackTopActivityLocked(
          ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
      if (targetStack != null && isFocusedStack(targetStack)) {
          return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
      }
      ... 
  }
  boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
     ...
      boolean result = false;
      try {
          // Protect against recursion.
          mStackSupervisor.inResumeTopActivity = true;
          ...
          result = resumeTopActivityInnerLocked(prev, options);
      } finally {
          mStackSupervisor.inResumeTopActivity = false;
      }
      return result;
  }
   //由于当前的Activity执行了onResume，所以mResumedActivity != null 条件满足，就会调用startPausingLocked方法先暂停当前的Activity。注意：这个过程必然是一个IPC过程。我们看一下startPausingLocked方法。
  private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
       ..
      // We need to start pausing the current activity so the top one can be resumed...
      ...
      if (mResumedActivity != null) {
          if (DEBUG_STATES) Slog.d(TAG_STATES,
                  "resumeTopActivityLocked: Pausing " + mResumedActivity);
          pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause);
      }
      ...
  }
     //方法中的PauseActivityItem时最后会执行他的execute方法，并将ClientTransactionHandler，也就是ActivityThread 的handlePauseActivity方法详细见下文分析
   final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,
              ActivityRecord resuming, boolean pauseImmediately) {
       if (prev.app != null && prev.app.thread != null) {

              try {
                    ...

                  mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,
                          PauseActivityItem.obtain(prev.finishing, userLeaving,
                                  prev.configChangeFlags, pauseImmediately));
              } catch (Exception e) {
                  // Ignore exception, if process died other code will cleanup.
                  Slog.w(TAG, "Exception thrown during pause", e);
                  mPausingActivity = null;
                  mLastPausedActivity = null;
                  mLastNoHistoryActivity = null;
              }
          } else {
              mPausingActivity = null;
              mLastPausedActivity = null;
              mLastNoHistoryActivity = null;
          }
   }
    //通过 mService.getLifecycleManager()获取到ClientLifecycleManager最终会调用下列方法
    void scheduleTransaction(ClientTransaction transaction) throws RemoteException {
          final IApplicationThread client = transaction.getClient();
          transaction.schedule();
          if (!(client instanceof Binder)) {
              // If client is not an instance of Binder - it's a remote call and at this point it is
              // safe to recycle the object. All objects used for local calls will be recycled after
              // the transaction is executed on client in ActivityThread.
              transaction.recycle();
          }
      }
    //  transaction.schedule();方法的执行是关键,，IPC过程,通过IApplicationThread对象执行scheduleTransaction方法
      public void schedule() throws RemoteException {
        mClient.scheduleTransaction(this);
  	 }
    //现在调用ActivityThread$ApplicationThread中的scheduleTransaction方法
     @Override
          public void scheduleTransaction(ClientTransaction transaction) throws RemoteException {
              ActivityThread.this.scheduleTransaction(transaction);
          }
     //因为ActivityThread继承于ClientTransactionHandler，所以scheduleTransaction方法是调用的父类的方法
     void scheduleTransaction(ClientTransaction transaction) {
          transaction.preExecute(this);
          sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
      }
    //sendMessage发送的handler消息EXECUTE_TRANSACTION，会在ActivityThread中的H中的handleMessage方法中进行处理
     case EXECUTE_TRANSACTION:
                      final ClientTransaction transaction = (ClientTransaction) msg.obj;
                      mTransactionExecutor.execute(transaction);
                      if (isSystem()) {
                          // message is handled.
                          transaction.recycle();
                      }
                      // TODO(lifecycler): Recycle locally scheduled transactions.
                      break;
   //通过mTransactionExecutor.execute(transaction);进行，查看TransactionExecutor中源码
     public void execute(ClientTransaction transaction) {
          final IBinder token = transaction.getActivityToken();
          
          executeCallbacks(transaction);

          executeLifecycleState(transaction);
          mPendingActions.clear();
          log("End resolving transaction");
      }
    //executeLifecycleState方法被执行，因为这只是single lifecycle state request，在activitystack中的startPausingLocked方法中参数为PauseActivityItem，所以在lifecycleItem.execute方法执行后会回到activitythread中的handlePauseActivity方法中
    private void executeLifecycleState(ClientTransaction transaction) {
  126        final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();
  127        if (lifecycleItem == null) {
  128            // No lifecycle request, return early.
  129            return;
  130        }
  131        log("Resolving lifecycle state: " + lifecycleItem);
  132
  133        final IBinder token = transaction.getActivityToken();
  134        final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
  135
  136        if (r == null) {
  137            // Ignore requests for non-existent client records for now.
  138            return;
  139        }
  140
  141        // Cycle to the state right before the final requested state.
  142        cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);
  143
  144        // Execute the final transition with proper parameters.
  145        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);
  146        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);
  147    }
      //PauseActivityItem中的execute方法
         public void execute(ClientTransactionHandler client, IBinder token,
              PendingTransactionActions pendingActions) {
          client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,
                  "PAUSE_ACTIVITY_ITEM");
      }
     //PauseActivityItem中的postExecute方法，很明显该方法中又是一次IPC过程，就是告诉AMS，已经暂停当前的Activity，可以启动新的Activity 了。
     @Override
      public void postExecute(ClientTransactionHandler client, IBinder token,
              PendingTransactionActions pendingActions) {
          if (mDontReport) {
              return;
          }
          try {
              // TODO(lifecycler): Use interface callback instead of AMS.
              ActivityManager.getService().activityPaused(token);
          } catch (RemoteException ex) {
              throw ex.rethrowFromSystemServer();
          }
      }
    //我们来看一下AMS的的activityPaused方法
      @Override
      public final void activityPaused(IBinder token) {
          final long origId = Binder.clearCallingIdentity();
          synchronized(this) {
              ActivityStack stack = ActivityRecord.getStackLocked(token);
              if (stack != null) {
                  stack.activityPausedLocked(token, false);
              }
          }
          Binder.restoreCallingIdentity(origId);
      }
  ```

  - AMS中的activityPaused又调用了ActivityStack的activityPausedLocked方法。

    ```java
    final void activityPausedLocked(IBinder token, boolean timeout) {
        ...
        final ActivityRecord r = isInStackLocked(token);
        if (r != null) {
            mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);
            if (mPausingActivity == r) {
                if (DEBUG_STATES) Slog.v(TAG_STATES, "Moving to PAUSED: " + r
                        + (timeout ? " (due to timeout)" : " (pause complete)"));
                completePauseLocked(true, null);
                return;
            } else {
               ...
            }
        }
       ...
    }
    ```

    - 在这个方法中又调用了ActivityStack自身的completePauseLocked方法，

      ```java
      private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) {
          ActivityRecord prev = mPausingActivity;
          if (resumeNext) {
              final ActivityStack topStack = mStackSupervisor.getFocusedStack();
              if (!mService.isSleepingOrShuttingDownLocked()) {
                  mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null);
              } else {
                 ...
              }
          }
          ...
      }
      ```

      - 这个流程我们上面讲过了，ActivityStackSupervisor会继续调用ActivityStack的resumeTopActivityUncheckedLocked方法，然后ActivityStack又调用其resumeTopActivityInnerLocked方法，调来调去，又到这个方法里面了，上次在这里是执行了前一个Activity的onPause方法,这次会调用 mService.getLifecycleManager().scheduleTransaction(transaction);   ResumeActivityItem对应的操作为启动新的activity

        ```java
        private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
            
            // We need to start pausing the current activity so the top one can be resumed...
            final boolean dontWaitForPause = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0;
            boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause);
            if (mResumedActivity != null) {
                if (DEBUG_STATES) Slog.d(TAG_STATES,
                        "resumeTopActivityLocked: Pausing " + mResumedActivity);
                pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause);
            }

            ...
            ActivityStack lastStack = mStackSupervisor.getLastStack();
            if (next.app != null && next.app.thread != null) {
                ...
                    transaction.setLifecycleStateRequest(
                                    ResumeActivityItem.obtain(next.app.repProcState,
                                            mService.isNextTransitionForward()));
                            mService.getLifecycleManager().scheduleTransaction(transaction);
            } else {
                ...
            }

            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            return true;
        }
        ```

- resumeactivityItem

- TransactionExecutorHelper通过mHelper.getLifecyclePath方法计算目标生命周期状态所需要执行的一系列生命周期，在 **TransactionExecutor**中执行executeLifecycleState方法时会调用

  ```java
  cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);
   
  private void cycleToPath(ActivityClientRecord r, int finish,
  161            boolean excludeLastState) {
    			//获取当前所处的生命周期状态，finish则是需要执行到哪个生命周期状态
  162        final int start = r.getLifecycleState();
  163
  164        final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);
  165        performLifecycleSequence(r, path);
  166    }
  
  
  ```

  - 从下面方法可以调用ActivityThread中的一系列生命周期方法

    ```
     /** Transition the client through previously initialized state sequence. */
    169    private void performLifecycleSequence(ActivityClientRecord r, IntArray path) {
    170        final int size = path.size();
    171        for (int i = 0, state; i < size; i++) {
    172            state = path.get(i);
    173            log("Transitioning to state: " + state);
    174            switch (state) {
    175                case ON_CREATE:
    176                    mTransactionHandler.handleLaunchActivity(r, mPendingActions,
    177                            null /* customIntent */);
    178                    break;
    179                case ON_START:
    180                    mTransactionHandler.handleStartActivity(r, mPendingActions);
    181                    break;
    182                case ON_RESUME:
    183                    mTransactionHandler.handleResumeActivity(r.token, false /* finalStateRequest */,
    184                            r.isForward, "LIFECYCLER_RESUME_ACTIVITY");
    185                    break;
    186                case ON_PAUSE:
    187                    mTransactionHandler.handlePauseActivity(r.token, false /* finished */,
    188                            false /* userLeaving */, 0 /* configChanges */, mPendingActions,
    189                            "LIFECYCLER_PAUSE_ACTIVITY");
    190                    break;
    191                case ON_STOP:
    192                    mTransactionHandler.handleStopActivity(r.token, false /* show */,
    193                            0 /* configChanges */, mPendingActions, false /* finalStateRequest */,
    194                            "LIFECYCLER_STOP_ACTIVITY");
    195                    break;
    196                case ON_DESTROY:
    197                    mTransactionHandler.handleDestroyActivity(r.token, false /* finishing */,
    198                            0 /* configChanges */, false /* getNonConfigInstance */,
    199                            "performLifecycleSequence. cycling to:" + path.get(size - 1));
    200                    break;
    201                case ON_RESTART:
    202                    mTransactionHandler.performRestartActivity(r.token, false /* start */);
    203                    break;
    204                default:
    205                    throw new IllegalArgumentException("Unexpected lifecycle state: " + state);
    206            }
    207        }
    208    }
    ```

  ```java
     public IntArray getLifecyclePath(int start, int finish, boolean excludeLastState) {
  60        if (start == UNDEFINED || finish == UNDEFINED) {
  61            throw new IllegalArgumentException("Can't resolve lifecycle path for undefined state");
  62        }
  63        if (start == ON_RESTART || finish == ON_RESTART) {
  64            throw new IllegalArgumentException(
  65                    "Can't start or finish in intermittent RESTART state");
  66        }
  67        if (finish == PRE_ON_CREATE && start != finish) {
  68            throw new IllegalArgumentException("Can only start in pre-onCreate state");
  69        }
  70
  71        mLifecycleSequence.clear();
  72        if (finish >= start) {
  73            // just go there
  74            for (int i = start + 1; i <= finish; i++) {
  75                mLifecycleSequence.add(i);
  76            }
  77        } else { // finish < start, can't just cycle down
  78            if (start == ON_PAUSE && finish == ON_RESUME) {
  79                // Special case when we can just directly go to resumed state.
  80                mLifecycleSequence.add(ON_RESUME);
  81            } else if (start <= ON_STOP && finish >= ON_START) {
  82                // Restart and go to required state.
  83
  84                // Go to stopped state first.
  85                for (int i = start + 1; i <= ON_STOP; i++) {
  86                    mLifecycleSequence.add(i);
  87                }
  88                // Restart
  89                mLifecycleSequence.add(ON_RESTART);
  90                // Go to required state
  91                for (int i = ON_START; i <= finish; i++) {
  92                    mLifecycleSequence.add(i);
  93                }
  94            } else {
  95                // Relaunch and go to required state
  96
  97                // Go to destroyed state first.
  98                for (int i = start + 1; i <= ON_DESTROY; i++) {
  99                    mLifecycleSequence.add(i);
  100                }
  101                // Go to required state
  102                for (int i = ON_CREATE; i <= finish; i++) {
  103                    mLifecycleSequence.add(i);
  104                }
  105            }
  106        }
         // Remove last transition in case we want to perform it with some specific params.
  109        if (excludeLastState && mLifecycleSequence.size() != 0) {
  110            mLifecycleSequence.remove(mLifecycleSequence.size() - 1);
  111        }
  112
  113        return mLifecycleSequence;
  114    }
  ```

- 同理会调用ActivityThread中的handleResumeActivity()方法，performResumeActivity（）-->activity.performResume()

- ActivityThread

  ```java
  public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving,
          int configChanges, PendingTransactionActions pendingActions, String reason) {
      ActivityClientRecord r = mActivities.get(token);
      if (r != null) {
        ...
          performPauseActivity(r, finished, reason, pendingActions);
  	...
      }
  }
  private Bundle performPauseActivity(
  			ActivityClientRecord r, boolean finished, String reason,
              PendingTransactionActions pendingActions) {
              ...
              performPauseActivityIfNeeded(r, reason);
              ...
              
              }
  private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) {
  ...
  try {
              r.activity.mCalled = false;
              mInstrumentation.callActivityOnPause(r.activity);
         ...
          } catch (SuperNotCalledException e) {
              throw e;
          } catch (Exception e) {
            ...
          }
  ...
  }
  //通过Instrumentation的callActivityOnPause
  public void callActivityOnPause(Activity activity) {
          activity.performPause();
      }
  //activity.performPause（）,最终会调用activity的onPause方法
  final void performPause() {
          mDoReportFullyDrawn = false;
          mFragments.dispatchPause();
          mCalled = false;
          onPause();
        ...
      }

  ```