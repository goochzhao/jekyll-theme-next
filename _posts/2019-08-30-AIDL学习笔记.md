---
title: AIDL的学习笔记
date: 2019-08-30 11:05
categories: 
- 源码分析
tags:
- android进阶
description: AIDL的学习笔记
---

## AIDL的学习笔记

### 概述

AIDL 意思即 Android Interface Definition Language，翻译过来就是Android接口定义语言，是用于定义服务器和客户端通信接口的一种描述语言，可以拿来生成用于IPC的代码。从某种意义上说AIDL其实是一个模板，因为在使用过程中，实际起作用的并不是AIDL文件，而是据此而生成的一个IInterface的实例代码，AIDL其实是为了避免我们重复编写代码而出现的一个模板，设计AIDL这门语言的目的就是为了实现进程间通信。在Android系统中，每个进程都运行在一块独立的内存中，在其中完成自己的各项活动，与其他进程都分隔开来。可是有时候我们又有应用间进行互动的需求，比较传递数据或者任务委托等，AIDL就是为了满足这种需求而诞生的。通过AIDL，可以在一个进程中获取另一个进程的数据和调用其暴露出来的方法，从而满足进程间通信的需求

### 语法

1. AIDL文件以 **.aidl** 为后缀名
2. AIDL支持的数据类型分为如下几种：
   - 八种基本数据类型：byte、char、short、int、long、float、double、boolean
   - String，CharSequence
   - 实现了Parcelable接口的数据类型
   - List 类型。List承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象
   - Map类型。Map承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象
3. AIDL文件可以分为两类。一类用来声明实现了Parcelable接口的数据类型，以供其他AIDL文件使用那些非默认支持的数据类型。还有一类是用来定义接口方法，声明要暴露哪些接口给客户端调用，定向Tag就是用来标注这些方法的参数值
4. 定向Tag。定向Tag表示在跨进程通信中数据的流向，用于标注方法的参数值，分为 in、out、inout 三种。其中 in 表示数据只能由客户端流向服务端， out 表示数据只能由服务端流向客户端，而 inout 则表示数据可在服务端与客户端之间双向流通。此外，如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。定向Tag具体的使用差别后边会有介绍
5. 明确导包。在AIDL文件中需要明确标明引用到的数据类型所在的包名，即使两个文件处在同个包名下

### 编写Server端代码



![1567139380590](C:\Users\gooch\AppData\Roaming\Typora\typora-user-images\1567139380590.png)

```java
// Book.aidl
package com.gooch.eventbusdemo;
// Declare any non-default types here with 
import statementsparcelable Book;
```



```java
// BookController.aidl
package com.gooch.eventbusdemo;
import com.gooch.eventbusdemo.Book;
// Declare any non-default types here with 
import statementsinterface BookController {    
    List<Book> getBookList();   
    void addBookInOut(inout Book book);
}
```

> 
>
> **Book.java**
>
> 



![1567139683404](C:\Users\gooch\AppData\Roaming\Typora\typora-user-images\1567139683404.png)

```java
package com.gooch.eventbusdemo;

import android.os.Parcel;
import android.os.Parcelable;


public class Book implements Parcelable {
    private String name;

    public Book(String name) {
        this.name = name;
    }

    protected Book(Parcel in) {
        name = in.readString();
    }

    public static final Creator<Book> CREATOR = new Creator<Book>() {
        @Override
        public Book createFromParcel(Parcel in) {
            return new Book(in);
        }

        @Override
        public Book[] newArray(int size) {
            return new Book[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(name);
    }
}

```

> 
>
> **这时会自动生成相关的AIDL代码，在build/source/aidl/debug/包名/...下查看自动生成的类**
>
> 

```java
/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Original file: D:\\workspace\\EventbusDemo\\app\\src\\main\\aidl\\com\\gooch\\eventbusdemo\\BookController.aidl
 */
package com.gooch.eventbusdemo;
// Declare any non-default types here with import statements

public interface BookController extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.gooch.eventbusdemo.BookController {
        private static final java.lang.String DESCRIPTOR = "com.gooch.eventbusdemo.BookController";

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.gooch.eventbusdemo.BookController interface,
         * generating a proxy if needed.
         */
        public static com.gooch.eventbusdemo.BookController asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) && (iin instanceof com.gooch.eventbusdemo.BookController))) {
                return ((com.gooch.eventbusdemo.BookController) iin);
            }
            return new com.gooch.eventbusdemo.BookController.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_getBookList: {
                    data.enforceInterface(DESCRIPTOR);
                    java.util.List<com.gooch.eventbusdemo.Book> _result = this.getBookList();
                    reply.writeNoException();
                    reply.writeTypedList(_result);
                    return true;
                }
                case TRANSACTION_addBookInOut: {
                    data.enforceInterface(DESCRIPTOR);
                    com.gooch.eventbusdemo.Book _arg0;
                    if ((0 != data.readInt())) {
                        _arg0 = com.gooch.eventbusdemo.Book.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    this.addBookInOut(_arg0);
                    reply.writeNoException();
                    if ((_arg0 != null)) {
                        reply.writeInt(1);
                        _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.gooch.eventbusdemo.BookController {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public java.util.List<com.gooch.eventbusdemo.Book> getBookList() throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                java.util.List<com.gooch.eventbusdemo.Book> _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);
                    _reply.readException();
                    _result = _reply.createTypedArrayList(com.gooch.eventbusdemo.Book.CREATOR);
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }

            @Override
            public void addBookInOut(com.gooch.eventbusdemo.Book book) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((book != null)) {
                        _data.writeInt(1);
                        book.writeToParcel(_data, 0);
                    } else {
                        _data.writeInt(0);
                    }
                    mRemote.transact(Stub.TRANSACTION_addBookInOut, _data, _reply, 0);
                    _reply.readException();
                    if ((0 != _reply.readInt())) {
                        book.readFromParcel(_reply);
                    }
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
        }

        static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_addBookInOut = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    }

    public java.util.List<com.gooch.eventbusdemo.Book> getBookList() throws android.os.RemoteException;

    public void addBookInOut(com.gooch.eventbusdemo.Book book) throws android.os.RemoteException;
}

```

> 创建Service,

```java
public class BookAIDLService extends Service {

    private List<Book> bookList;

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return stub;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        bookList = new ArrayList<>();
        initData();
    }

    private void initData() {
        Book book1 = new Book("拉开圣诞节");
        Book book2 = new Book("卡逻辑");
        Book book3 = new Book("空间的是否");
        Book book4 = new Book("考虑");
        bookList.add(book1);
        bookList.add(book2);
        bookList.add(book3);
        bookList.add(book4);
    }

    private final BookController.Stub stub = new BookController.Stub() {
        @Override
        public List<Book> getBookList() throws RemoteException {
            return bookList;
        }

        @Override
        public void addBookInOut(Book book) throws RemoteException {
            if (book != null) {
                bookList.add(book);
            }
        }
    };
}

```

![1567145512613](C:\Users\gooch\AppData\Roaming\Typora\typora-user-images\1567145512613.png)

### Client代码

客户端需要再创建一个新的工程，包名命名为 **com.gooch.eventbusdemo.client**

首先，需要把服务端的AIDL文件以及Book类复制过来，将 aidl 文件夹整个复制到和Java文件夹同个层级下，不需要改动任何代码

之后，需要创建和服务端Book类所在的相同包名来存放 Book类

> 建立连接和Server端

```java
 private ServiceConnection serviceConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            bookController = BookController.Stub.asInterface(service);
            connected = true;
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            connected = false;
        }
    };
```

> 绑定服务端

```java
   private void bindService() {
        Intent intent = new Intent();
        intent.setPackage("com.czy.server");
        intent.setAction("com.czy.server.action");
        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
    }
```

### 定向Tag

我再来讲下三种定向Tag之间的差别。上边使用的是 InOut 类型，服务端对数据的改变同时也同步到了客户端，因此可以说两者之间数据是双向流动的

In 类型的表现形式是：数据只能由客户端传向服务端，服务端对数据的修改不会影响到客户端

Out类型的表现形式是：数据只能由服务端传向客户端，即使客户端向方法接口传入了一个对象，该对象中的属性值也是为空的，即不包含任何数据，服务端获取到该对象后，对该对象的任何操作，就会同步到客户端这边