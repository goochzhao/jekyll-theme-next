---
title: 面向对象的设计原则
date: 2018-04-27 11:44
categories:
- 设计模式
tags:
- 设计模式
description: 面向对象的思想能够让我们的代码变得更为清晰有逻辑。

---

# 面向对象的六大原则

## 单一原则

这里举一个简单栗子进行阐述，（栗子：为什么要举我:cry: )

> 下面看一个`ImageLoader` 的加载栗子

```java
public class ImageLoader {
    static class ShowHandler extends Handler {

    }

    private ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    private ImageCache mImageCache;
    private ShowHandler mShowHandler;

    public ImageLoader() {
        mImageCache = new ImageCache();
        mShowHandler = new ShowHandler();
    }


    public void showImage(final String imgUrl, final ImageView imageView) {
        if (imageView == null) {
            return;
        }
        imageView.setTag(imgUrl);
        if (mImageCache.get(imgUrl) == null) {
            setNetImg(imgUrl, imageView);
        } else {
            imageView.setImageBitmap(mImageCache.get(imgUrl));
        }

    }

    private void setNetImg(final String imgUrl, final ImageView imageView) {
        mExecutorService.submit(new Runnable() {
            @Override
            public void run() {
                final Bitmap bitmap = downLoadImg(imgUrl);
                mShowHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (TextUtils.equals(imgUrl, (CharSequence) imageView.getTag())) {
                            imageView.setImageBitmap(bitmap);
                        }
                    }
                });
                mImageCache.put(imgUrl, bitmap);
            }
        });
    }

    private Bitmap downLoadImg(String imgUrl) {
        Bitmap bitmap = null;
        HttpURLConnection httpURLConnection = null;
        try {
            URL url = new URL(imgUrl);
            httpURLConnection = (HttpURLConnection) url.openConnection();
            InputStream inputStream = httpURLConnection.getInputStream();
            bitmap = BitmapFactory.decodeStream(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (httpURLConnection != null) {
                httpURLConnection.disconnect();
            }
        }
        return bitmap;
    }
}
```

在这里呢进行了将缓存和加载进行了单一职责，将缓存单独拿出去这样增加了代码的灵活性，当然这里还可以将bitmap的获取拿出去封装再一次进行单一职责，在这里没有去处理。

> 基本的指导原则：两个完全不一样的功能不应该放在一个类中，应该进行业务和功能上的拆分，这是优化程序的第一步。

## 开闭原则和里氏替换原则

这两者一般是结合使用的，

```java

public interface IImageCache {
    
    void put(String key, Bitmap bitmap);

    Bitmap get(String key);
}
```

通过下列方法设置不同的缓存策略：

```java
public void setImageCache(IImageCache imageCache) {
        mImageCache = imageCache;
   }
```

由此不用更改ImageLoader类即可实现不同的加载策略，做到了开放与封闭原则，增加了程序的可扩展性，而我们可以通过实现IImageCache接口创建不同的缓存策略，所以实现了用户对缓存策略更换的灵活性，和可定制性，这两个原则就是建立在抽象的基础上，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的扩展性、灵活性。

## 依赖倒置原则



> 依赖倒置原则

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节不应该依赖抽象

> 在java语言中的表现就是： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。

在单一原则中的ImageLoader中的实现中，我们直接使用的是内存缓存策略，而这是一个具体实现细节，而这就违背了依赖倒置原则，高层模块依赖了低层模块细节，导致了代码的灵活性较差，细节没有依赖抽象，类与类之间直接依赖于细节，之间有了直接的耦合。

## 接口隔离原则

通过细化接口，简单的说就是，让客户端依赖的接口尽可能的小，上述IImageLoader接口则是应用，通过改接口将缓存功能进行了细化，隔离了具体的实现细节。

## 迪米特原则

这个主要是讲类与类之间的功能解耦，一个类只需要知道自己需要的方法即可其他的不用去管，类和类之间的关系越密切，耦合度越大，当一个类发生变化时，对另一个类可能影响也越大。

还是拿上边的ImageLoader举例，比如用户使用了磁盘的缓存策略，而用户不用去管你的磁盘缓存怎么实现，我只需要知道去设置磁盘缓存策略即可，所以不管你的磁盘缓存方法怎么实现和调用者没关系。